# Basics of Datomic schemas

As mentioned before, Datomic stores facts, in the shape of datoms.
Datoms are a way to represent *attributes* that are linked by an
entity id.

> Attributes are modelled the same way as application data, and
> have to be transacted using a particular schema

## How to create attributes

The only required property of an attribute is `:db/ident`. This specifies
the **unique** name of an attribute. This corresponds to a *namespaced
keyword*. The namespace is a good practice for avoiding name collision.

**Important:** The `:db` namespace is reserved for Datomic. Trying to modify
any property in this namespace is forbidden.

Attributes also have a value type. This is like any other database, like
PosgreSQL or MongoDB. All possible value types can be found in
[the docs](https://docs.datomic.com/pro/schema/schema.html#value-types).
However, there is one that is absolutely important: `:db.type/ref`. This
value allows to perform joins between different entities, linked by a
ref-valued attribute in one of them.

> Recommendation is that joins always use entity ids. I've seen that it
> is possible to perform joins using other types of identifiers, but
> using entity ids is more efficient

### How to define identifiers for entities 

There are three main ways to uniquely identify an entity:

* The entity id (`:db/id`)
* An ident (`{:db/ident :namespace/attr}`)
* Look up refs

Entity ids are autogenerated, and correspond to integer values. These
are fairly straightforward, and are very similar to other database
implementations of these ids.

Now, an ident specifies a way to link an entity id to a *keyword*.
That allows usage of this keyword instead of the entity id on queries
or other referencing operations.

> Idents should be used for attribute naming or for enumerated tags.

A look-up ref is specified by a pair `[:namespace/attr attr-val]` (an
*ident* in the context of EQL). It can be used to substitute the entity
id when performing direct entity search or transactions.

> Look-up refs should include attributes of the types `:db.unique/value`
> or `db.unique/identity`. Those are specified in the property `db/unique`
> of an attribute schema.

**Important:** The unique values and unique identities have the same
semantics. However, unique identities fallback to a previously existing
identity in case of duplicate value, while unique values raise an
exception.

> The suggestion for using uuids as unique identifiers is to define them
> as an attribute with the type `:db.type/uuid`.

Personally, I would prefer to use entity ids for everything! Why?
Because look-up refs cannot be used in queries. The workaround is
to use pulls, as I will show shortly.

### Transacting attributes

In order to be able to use attributes, they must be stored in the database.
This is done by using the `d/transact` method from teh client API, and the
connection to the peer server

```clojure
(d/transact conn {:tx-data ops-list})
```

Where `ops-list` is a list of lists. Each list contains a set of operations
to be executed. the operation can also be summarized as an object, which is
what is commonly done for transacting attributes. Consider a simple user
schema

```clojure
(def user-schema [{:db/ident       :user/name
                   :db/valueType   :db.type/string
                   :db/cardinality :db.cardinality/one
                   :db/doc         "User name"}

                  {:db/ident       :user/last-name
                   :db/valueType   :db.type/string
                   :db/cardinality :db.cardinality/one
                   :db/doc         "User last name"}

                  {:db/ident       :user/age
                   :db/valueType   :db.type/long
                   :db/cardinality :db.cardinality/one
                   :db/doc         "User age"}

                  {:db/ident       :user/role
                   :db/valueType   :db.type/keyword
                   :db/cardinality :db.cardinality/one
                   :db/doc         "User roles [:owner :crew :support :reporter]"}

                  {:db/ident       :user/email
                   :db/valueType   :db.type/string
                   :db/cardinality :db.cardinality/one
                   :db/unique      :db.unique/identity
                   :db/doc         "User email. used for authentication"}])
```

Notice that this schema is a list, where each element is an operation that
indicates the creation of a particular attribute for a user in the database.
To create those attributes, simply transact them!

```clojure
(d/transact conn {:tx-data user-schema})
```
